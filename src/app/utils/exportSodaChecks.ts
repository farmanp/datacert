import { ProfileResult } from '../stores/profileStore';

export interface SodaExportOptions {
  tableName: string;
  tolerancePct: number; // e.g., 10 for 10%
  includeWarnings?: boolean;
}

/**
 * Generates a SodaCL YAML file based on profiling results.
 */
export function generateSodaChecksYAML(results: ProfileResult, options: SodaExportOptions): string {
  const { tableName, tolerancePct, includeWarnings = true } = options;
  const toleranceMultiplier = tolerancePct / 100;

  let yaml = `# Generated by DataCert\n`;
  yaml += `# Date: ${new Date().toISOString()}\n`;
  yaml += `# Tolerance: ${tolerancePct}%\n\n`;
  yaml += `checks for ${tableName}:\n`;

  // Global checks
  yaml += `  - row_count > 0\n`;

  for (const col of results.column_profiles) {
    yaml += `\n  # Column: ${col.name}\n`;

    const count = col.base_stats.count;
    const missing = col.base_stats.missing;
    const missingPct = (missing / count) * 100;

    // 1. Missing values check
    // We expect the current missing percent + tolerance as a fail threshold
    const missingThreshold = Math.ceil(missingPct * (1 + toleranceMultiplier) + 1); // +1 as a buffer
    if (missing === 0) {
      yaml += `  - missing_count(${col.name}) = 0\n`;
    } else {
      yaml += `  - missing_percent(${col.name}) < ${missingThreshold}\n`;
    }

    // 2. Uniqueness check
    const distinct = col.base_stats.distinct_estimate;
    const validCount = count - missing;
    if (validCount > 0 && distinct >= validCount * 0.999) {
      // Practically unique
      yaml += `  - duplicate_count(${col.name}) = 0\n`;
    }

    // 3. Numeric checks
    if (col.numeric_stats) {
      const stats = col.numeric_stats;

      // Min/Max with tolerance
      const minThreshold =
        stats.min >= 0
          ? stats.min * (1 - toleranceMultiplier)
          : stats.min * (1 + toleranceMultiplier);
      const maxThreshold =
        stats.max >= 0
          ? stats.max * (1 + toleranceMultiplier)
          : stats.max * (1 - toleranceMultiplier);

      yaml += `  - min(${col.name}) >= ${formatNum(minThreshold)}\n`;
      yaml += `  - max(${col.name}) <= ${formatNum(maxThreshold)}\n`;

      // Mean (Average) with tolerance range
      const avgLower = stats.mean * (1 - toleranceMultiplier);
      const avgUpper = stats.mean * (1 + toleranceMultiplier);

      if (includeWarnings) {
        yaml += `  - avg(${col.name}):\n`;
        yaml += `      fail: when not between ${formatNum(avgLower)} and ${formatNum(avgUpper)}\n`;
        // Optional: warn if closer to boundaries
        const warnLower = stats.mean * (1 - toleranceMultiplier / 2);
        const warnUpper = stats.mean * (1 + toleranceMultiplier / 2);
        yaml += `      warn: when not between ${formatNum(warnLower)} and ${formatNum(warnUpper)}\n`;
      } else {
        yaml += `  - avg(${col.name}) between ${formatNum(avgLower)} and ${formatNum(avgUpper)}\n`;
      }
    }

    // 4. Schema checks (Inferred type)
    const sodaType = mapToSodaType(col.base_stats.inferred_type);
    if (sodaType) {
      yaml += `  - schema:\n`;
      yaml += `      warn:\n`;
      yaml += `        when wrong column type:\n`;
      yaml += `          ${col.name}: ${sodaType}\n`;
    }
  }

  return yaml;
}

function formatNum(n: number): string {
  if (Math.abs(n) < 0.01) return n.toExponential(4);
  return n.toLocaleString('en-US', {
    useGrouping: false,
    maximumFractionDigits: 4,
  });
}

function mapToSodaType(type: string): string | null {
  const lower = type.toLowerCase();
  if (lower.includes('integer')) return 'integer';
  if (lower.includes('numeric') || lower.includes('float')) return 'decimal';
  if (lower.includes('string') || lower.includes('text')) return 'text';
  if (lower.includes('boolean')) return 'boolean';
  if (lower.includes('date')) return 'date';
  return null;
}
